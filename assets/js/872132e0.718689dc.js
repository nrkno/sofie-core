"use strict";(self.webpackChunksofie_documentation=self.webpackChunksofie_documentation||[]).push([[3383],{16620:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=n(62540),i=n(43023);const o={},a="AB Playback",r={id:"for-developers/for-blueprint-developers/ab-playback",title:"AB Playback",description:"This page talks about various sections that are in NRK's blueprints which are not yet public. Other blueprints (such as those from TV 2 Danmark) make use of AB playback, but may not match up completely with what is documented here.",source:"@site/versioned_docs/version-1.46.0/for-developers/for-blueprint-developers/ab-playback.md",sourceDirName:"for-developers/for-blueprint-developers",slug:"/for-developers/for-blueprint-developers/ab-playback",permalink:"/sofie-core/docs/1.46.0/for-developers/for-blueprint-developers/ab-playback",draft:!1,unlisted:!1,editUrl:"https://github.com/nrkno/sofie-core/edit/master/packages/documentation/versioned_docs/version-1.46.0/for-developers/for-blueprint-developers/ab-playback.md",tags:[],version:"1.46.0",frontMatter:{},sidebar:"forDevelopers",previous:{title:"Introduction",permalink:"/sofie-core/docs/1.46.0/for-developers/for-blueprint-developers/intro"},next:{title:"Hold",permalink:"/sofie-core/docs/1.46.0/for-developers/for-blueprint-developers/hold"}},l={},c=[{value:"Defining",id:"defining",level:2},{value:"Resolving",id:"resolving",level:2},{value:"Applying the result",id:"applying-the-result",level:2}];function h(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"ab-playback",children:"AB Playback"}),"\n",(0,s.jsx)(t.admonition,{type:"caution",children:(0,s.jsxs)(t.p,{children:["This page talks about various sections that are in NRK's blueprints which are not yet public. Other blueprints (such as those from ",(0,s.jsx)(t.a,{href:"https://github.com/tv2/sofie-blueprints-inews",children:"TV 2 Danmark"}),") make use of AB playback, but may not match up completely with what is documented here.",(0,s.jsx)(t.br,{}),"\n","We are looking into pushing more of this logic into Sofie to aid reusability."]})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"AB Playback"})," is a common technique for clip playback. The aim is to be able to play multiple clips back to back, alternating which player is used for each clip.",(0,s.jsx)(t.br,{}),"\n","At first glance it sounds simple to handle, but it quickly becomes complicated when we consider the need to allow users to run adlibs and that the system needs to seamlessly update pre-programmed clips when this happens."]}),"\n",(0,s.jsxs)(t.p,{children:["To avoid this problem, we take an approach of simply labelling pieces as needing an AB assignment and leaving timeline objects to have some unresolved values during the ingest blueprint operations, and use the ",(0,s.jsx)(t.code,{children:"onTimelineGenerate"})," blueprint function to do the assignment and modify the timeline as needed at the time of playout."]}),"\n",(0,s.jsx)(t.p,{children:"There are other challenges to think about too:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Users get confused if the player of a clip changes without a reason"}),"\n",(0,s.jsx)(t.li,{children:"Reloading an already loaded clip can be costly, so should be avoided when possible"}),"\n",(0,s.jsx)(t.li,{children:"Adlibbing a clip, or changing what Part is nexted can result in needing to move what player a clip has assigned"}),"\n",(0,s.jsx)(t.li,{children:"Postroll or preroll is often needed"}),"\n",(0,s.jsx)(t.li,{children:"Some studios can have less players available than ideal. (eg, going back to back between two clips, and a clip is playing on the studio monitor)"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"defining",children:"Defining"}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"This method of defining sessions is just a suggestion, it could be done in many other ways depending on how you wish to implement it."})}),"\n",(0,s.jsxs)(t.p,{children:["As AB playback is currently mostly blueprints driven, Sofie Core is unaware of which pieces want AB playback. Instead, we track AB session requests in the ",(0,s.jsx)(t.code,{children:"metaData"})," field on each Piece using the structure:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export interface AbSessionInfo {\n\tname: string\n\tpool: AbSessionPool\n\toptional?: boolean\n}\n\nexport interface IPieceMetaData {\n\tabSessions?: AbSessionInfo[]\n\t// Unrelated properties here\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This allows each piece to request multiple AB sessions, with the information we need about each session. In the simplest form, ",(0,s.jsx)(t.code,{children:"pool"})," and ",(0,s.jsx)(t.code,{children:"optional"})," are not required. ",(0,s.jsx)(t.code,{children:"pool"})," allows us to have multiple AB pools for different purposes (eg clips and DVE channels). ",(0,s.jsx)(t.code,{children:"optional"})," allows us to know that it is safe to ignore this request if there is no available player. For example, if there are not enough players to allocate one to the studio monitor, it can be left on the holding loop."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"name"})," is used as an identifier for this session. It is used to allow for multiple sessions to exist in the same Piece or Part, while being able to match up Pieces which should be using the same session. Make sure you don't reuse a name accidentally within a Segment, or it will be treated as the same session."]}),"\n",(0,s.jsxs)(t.p,{children:["In addition to labelling the pieces, we are labelling the timeline objects which are affected by this too. This allows us to easily update any affected timeline objects with generic logic.",(0,s.jsx)(t.br,{}),"\n","This is done in a similar way to Pieces, using the ",(0,s.jsx)(t.code,{children:"metaData"})," property on the objects:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export interface TimelineObjectMetaData {\n\tabSessions?: Omit<AbSessionInfo, 'optional'>[]\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"The value of these sessions must match one of those used by the Piece, or our logic will not create the needed session for the object."}),"\n",(0,s.jsxs)(t.p,{children:["If you are defining an object which needs to target a different layer mapping depending on which layer is chosen, we put these objects on a ",(0,s.jsx)(t.code,{children:"pending"})," layer. For the pool of ",(0,s.jsx)(t.code,{children:"casparcg_player_clip_1"})," and ",(0,s.jsx)(t.code,{children:"casparcg_player_clip_2"}),", all our objects get generated for the abstract layer ",(0,s.jsx)(t.code,{children:"casparcg_player_clip_pending"}),". It is on this pending layer that we enable lookahead, not the real layers. This allows lookahead to run, and the resulting objects get handled by our AB resolving logic below."]}),"\n",(0,s.jsx)(t.h2,{id:"resolving",children:"Resolving"}),"\n",(0,s.jsx)(t.p,{children:"Resolving is done as a multi-stage process. At each stage we only consider one AB pool at a time, processing each in turn."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Build an array of all the requested sessions"}),"\n",(0,s.jsx)(t.li,{children:"Resolve the sessions"}),"\n",(0,s.jsx)(t.li,{children:"Apply the result"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Finding all the requested sessions is a fairly straight-forward process, and is checking the ",(0,s.jsx)(t.code,{children:"abSessions"})," property inside the ",(0,s.jsx)(t.code,{children:"metaData"})," for each Piece.",(0,s.jsx)(t.br,{}),"\n","To do this we convert each session ",(0,s.jsx)(t.code,{children:"name"})," into an id with ",(0,s.jsx)(t.code,{children:"context.getPieceABSessionId()"}),". This is a method provided by core to help make a persistent id, while allowing for the id to change when playing Parts out of order. We then track the bounds needed for each sessionId, considering that the session may span multiple Pieces which might overlap or might be disconnected.",(0,s.jsx)(t.br,{}),"\n","We also create sessions for each of the lookahead objects that are in the timeline with a session request, making sure to order them by their priority. We use ",(0,s.jsx)(t.code,{children:"context.getTimelineObjectAbSessionId()"})," to generate the sessionId for these objects. The sessionId will be remembered through to when we have a PieceInstance for the object and can use ",(0,s.jsx)(t.code,{children:"context.getPieceABSessionId()"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Next up is assigning each session to a player. We prepare by re-assigning any session which is currently on air (or will be within a couple of seconds) the same value as last time we ran. To persist this we make use of ",(0,s.jsx)(t.code,{children:"TimelinePersistentState"})," that is available to ",(0,s.jsx)(t.code,{children:"onTimelineGenerate"}),". This ensures that anything currently playing doesnt move player unexpectedly. Anything which has no chance of being preloaded or being played yet has any existing assignment removed.",(0,s.jsx)(t.br,{}),"\n","Any sessions which clash or collide with an on-air session are also cleared."]}),"\n",(0,s.jsxs)(t.p,{children:["Then we iterate through each pending session, in the order they will start in. There are a load of checks here, to choose a player which has been refined over time and a lot of experimentation, which are not worth attempting to describe here.",(0,s.jsx)(t.br,{}),"\n","We run a limited number of iterations here, as it is possible for it to clear the session assigned to another player in certain conditions. And crucially, if both players are good candidates, we go with the player we chose last time (as recorded in ",(0,s.jsx)(t.code,{children:"TimelinePersistentState"}),") to avoid confusion from users.\nOnce all the Piece bases sessions have been allocated, we assign a lookahead to each player to be used once its sessions have finished. We expect to not have enough players for each lookahead."]}),"\n",(0,s.jsxs)(t.p,{children:["Now we are ready to track the result on the new ",(0,s.jsx)(t.code,{children:"TimelinePersistentState"})," and apply the result to the timeline."]}),"\n",(0,s.jsx)(t.h2,{id:"applying-the-result",children:"Applying the result"}),"\n",(0,s.jsx)(t.p,{children:"Now that all the AB sessions are resolved, and we know what player to use for each Piece we can update the timeline objects to reflect this."}),"\n",(0,s.jsx)(t.p,{children:"To make this as simple and generic as possible, we developed a shortcut to achieving this by using keyframes."}),"\n",(0,s.jsx)(t.p,{children:"For example, ingest will create the following object intended to put the clip on air:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"let obj = {\n\tid: id || '',\n\tenable: { start: 0 },\n\tlayer: 'atem_me_program',\n\tcontent: {\n\t\tdeviceType: TSR.DeviceType.ATEM,\n\t\ttype: TSR.TimelineContentTypeAtem.ME,\n\t\tme: {\n\t\t\tinput: 0, // fallback\n\t\t\ttransition: TSR.AtemTransitionStyle.CUT,\n\t\t},\n\t},\n\tkeyframes: [\n\t\t{\n\t\t\tid: `mp_1`,\n\t\t\tenable: { while: '1' },\n\t\t\tdisabled: true,\n\t\t\tcontent: {\n\t\t\t\tinput: 10,\n\t\t\t},\n\t\t\tpreserveForLookahead: true,\n\t\t\tmetaData: {\n\t\t\t\tabSession: {\n\t\t\t\t\tpool: 'clip',\n\t\t\t\t\tindex: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: `mp_2`,\n\t\t\tenable: { while: '1' },\n\t\t\tdisabled: true,\n\t\t\tcontent: {\n\t\t\t\tinput: 11,\n\t\t\t},\n\t\t\tpreserveForLookahead: true,\n\t\t\tmetaData: {\n\t\t\t\tabSession: {\n\t\t\t\t\tpool: 'clip',\n\t\t\t\t\tindex: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n\tmetaData: {\n\t\tabSessions: [\n\t\t\t{\n\t\t\t\tpool: 'clip',\n\t\t\t\tname: 'abcdef',\n\t\t\t},\n\t\t],\n\t},\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This object is long, but by using keyframes we have defined how to modify it for each AB player that it could be assigned to. By looking at the ",(0,s.jsx)(t.code,{children:"abSession"})," inside ",(0,s.jsx)(t.code,{children:"metaData"})," for each keyframe, we can determine if the keyframe is for the player it was assigned. If the keyframe matches, we unset the ",(0,s.jsx)(t.code,{children:"disabled"})," property, and that is it.",(0,s.jsx)(t.br,{}),"\n","The main benefit here is that everything needed to handle AB for this object is defined at the time the Piece was created."]}),"\n",(0,s.jsxs)(t.p,{children:["While this works in some cases, it does not work in others. For example, it does not let us correctly direct the object playing the clip to the correct player as that requires changing the ",(0,s.jsx)(t.code,{children:"layer"})," property of the object."]}),"\n",(0,s.jsx)(t.p,{children:"Instead we solve this by having a simple lookup table defining how to translate different layers.\nFor casparcg this looks like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"interface MoveRule {\n\tpools: AbSessionPool[]\n\tnewLayer: (playerId: number) => string\n\tallowsLookahead: boolean\n}\n\nconst MOVABLE_LAYERS: {\n\t[layer: string]: MoveRule | undefined\n} = {\n\t['casparcg_player_clip_pending']: {\n\t\tpools: [AbSessionPool.CLIP],\n\t\tnewLayer: (i: number) => `casparcg_player_clip_${i}`,\n\t\tallowsLookahead: true,\n\t},\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that this is also using the ",(0,s.jsx)(t.code,{children:"casparcg_player_clip_pending"})," layer as we described above. After this step, the objects are now on the correct layers to be consumed by playout-gateway."]}),"\n",(0,s.jsx)(t.p,{children:"Finally, we have some very custom logic to handle some layers that need properties to be changed deep inside their content. This is a hack and may no longer be necessary. We would encourage avoiding this if possible."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},43023:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(63696);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);