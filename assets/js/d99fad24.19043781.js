"use strict";(self.webpackChunksofie_documentation=self.webpackChunksofie_documentation||[]).push([[8781],{5318:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=r,f=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return n?a.createElement(f,i(i({ref:t},d),{},{components:n})):a.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},363:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(5773),r=(n(7378),n(5318));const o={title:"Sync Ingest Changes"},i=void 0,s={unversionedId:"for-developers/for-blueprint-developers/sync-ingest-changes",id:"for-developers/for-blueprint-developers/sync-ingest-changes",title:"Sync Ingest Changes",description:"Since PartInstances and PieceInstances were added to Sofie, the default behaviour in Sofie is to not propogate any ingest changes from a Part onto its PartInstances.",source:"@site/docs/for-developers/for-blueprint-developers/sync-ingest-changes.md",sourceDirName:"for-developers/for-blueprint-developers",slug:"/for-developers/for-blueprint-developers/sync-ingest-changes",permalink:"/sofie-core/docs/for-developers/for-blueprint-developers/sync-ingest-changes",draft:!1,editUrl:"https://github.com/nrkno/sofie-core/edit/master/packages/documentation/docs/for-developers/for-blueprint-developers/sync-ingest-changes.md",tags:[],version:"current",frontMatter:{title:"Sync Ingest Changes"},sidebar:"forDevelopers",previous:{title:"Part and Piece Timings",permalink:"/sofie-core/docs/for-developers/for-blueprint-developers/part-and-piece-timings"},next:{title:"Timeline Datastore",permalink:"/sofie-core/docs/for-developers/for-blueprint-developers/timeline-datastore"}},l={},p=[{value:"Tips",id:"tips",level:3}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Since PartInstances and PieceInstances were added to Sofie, the default behaviour in Sofie is to not propogate any ingest changes from a Part onto its PartInstances."),(0,r.kt)("p",null,"This is a safety net as without a detailed understanding of the Part and the change, we can't know whether it is safe to make on air. Without this, it would be possible for the user to change a clip name in the NRCS, and for Sofie to happily propogate that could result in a sudden change of clip mid sentence, or black if the clip needed to be copied to the playout server. This gets even more complicated when we consider that an adlib-action could have already modified a PartInstance, with changes that should likely not be overwritten with the newly ingested Part."),(0,r.kt)("p",null,"Instead, this propogation can be implemented by a ShowStyle blueprint in the ",(0,r.kt)("inlineCode",{parentName:"p"},"syncIngestUpdateToPartInstance")," method, in this way the implementation can be tailored to understand the change and its potential impact. This method is able to update the previous, current and next PartInstances. Any PartInstances older than the previous is no longer being used on the timeline so is now simply a record of how it was played and updating it would have no benefit. Sofie never has any further than the next PartInstance generated, so for any Part after that the Part is all that exists for it, so any changes will be used when it becomes the next."),(0,r.kt)("p",null,"In this blueprint method, you are able to update almost any of the properties that are available to you both during ingest, and during adlib actions. It is possible the leave the Part in a broken state after this, so care must be taken to ensure it is not. If the call to your method throws an uncaught error, the changes you have made so far will be discarded but the rest of the ingest operation will continue as normal."),(0,r.kt)("h3",{id:"tips"},"Tips"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You should make use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"metaData")," fields on each Part and Piece to help work out what has changed. At NRK, we store the parsed ingest data (after converting the MOS to an intermediary json format) for the Part here, so that we can do a detailed diff to figure out whether a change is safe to accept.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You should track in ",(0,r.kt)("inlineCode",{parentName:"p"},"metaData")," whether a part has been modified by an adlib-action in a way that makes this sync unsafe.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"At NRK, we differentiate the Pieces into ",(0,r.kt)("inlineCode",{parentName:"p"},"primary"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"secondary"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"adlib"),". This allows us to control the updates more granularly.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"newData.part")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," when the PartInstance is orphaned. Generally, it's useful to differentiate the behavior of the implementation of this function based on ",(0,r.kt)("inlineCode",{parentName:"p"},"existingPartInstance.partInstance.orphaned")," state")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"playStatus: previous")," means that the currentPartInstance is ",(0,r.kt)("inlineCode",{parentName:"p"},"orphaned: adlib-part")," and thus possibly depends on an already past PartInstance for some of it's properties. Therefore the blueprint is allowed to modify the most recently played non-adlibbed PartInstance using ingested data."))))}u.isMDXComponent=!0}}]);